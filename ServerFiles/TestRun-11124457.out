
R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #### Calling everything from this Script
> 
> # printing wd
> cat(getwd())
/home/fkarimi2/SimulatingNormativeConflict/ServerFiles> 
> # apparently, the working directory is the dir of the bash file
> # so we have to ge up once
> setwd("..")
> 
> # print the Ntasks setting from SLURM
> cat(strtoi(Sys.getenv(c("SLURM_NTASKS"))))
20> 
> # loading parallel libraries
> library(parallel)
> library(snow)

Attaching package: ‘snow’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, clusterSplit, makeCluster, parApply,
    parCapply, parLapply, parRapply, parSapply, splitIndices,
    stopCluster

> library(Rmpi)
> 
> # making cluster
> cl <- makeCluster(strtoi(Sys.getenv(c("SLURM_NTASKS")))-1, type="MPI");cl
	19 slaves are spawned successfully. 0 failed.
[[1]]
$rank
[1] 1

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[2]]
$rank
[1] 2

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[3]]
$rank
[1] 3

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[4]]
$rank
[1] 4

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[5]]
$rank
[1] 5

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[6]]
$rank
[1] 6

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[7]]
$rank
[1] 7

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[8]]
$rank
[1] 8

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[9]]
$rank
[1] 9

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[10]]
$rank
[1] 10

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[11]]
$rank
[1] 11

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[12]]
$rank
[1] 12

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[13]]
$rank
[1] 13

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[14]]
$rank
[1] 14

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[15]]
$rank
[1] 15

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[16]]
$rank
[1] 16

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[17]]
$rank
[1] 17

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[18]]
$rank
[1] 18

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

[[19]]
$rank
[1] 19

$RECVTAG
[1] 33

$SENDTAG
[1] 22

$comm
[1] 1

attr(,"class")
[1] "MPInode"

attr(,"class")
[1] "spawnedMPIcluster" "MPIcluster"        "cluster"          
> 
> # Testing how many cores are available accross the whole cluster
> mpi.universe.size()
[1] 20
> 
> # We need to export all necessary libraries to all the slave nodes to make them available
> clusterEvalQ(cl,suppressMessages(library(igraph)))
[[1]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[2]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[3]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[4]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[5]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[6]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[7]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[8]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[9]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[10]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[11]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[12]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[13]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[14]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[15]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[16]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[17]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[18]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

[[19]]
 [1] "igraph"    "snow"      "Rmpi"      "stats"     "graphics"  "grDevices"
 [7] "utils"     "datasets"  "methods"   "base"     

> clusterEvalQ(cl,suppressMessages(library(tidyverse)))
[[1]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[2]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[3]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[4]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[5]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[6]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[7]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[8]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[9]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[10]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[11]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[12]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[13]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[14]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[15]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[16]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[17]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[18]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

[[19]]
 [1] "forcats"   "stringr"   "dplyr"     "purrr"     "readr"     "tidyr"    
 [7] "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"      "Rmpi"     
[13] "stats"     "graphics"  "grDevices" "utils"     "datasets"  "methods"  
[19] "base"     

> clusterEvalQ(cl,suppressMessages(library(tictoc)))
[[1]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[2]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[3]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[4]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[5]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[6]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[7]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[8]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[9]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[10]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[11]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[12]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[13]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[14]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[15]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[16]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[17]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[18]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

[[19]]
 [1] "tictoc"    "forcats"   "stringr"   "dplyr"     "purrr"     "readr"    
 [7] "tidyr"     "tibble"    "ggplot2"   "tidyverse" "igraph"    "snow"     
[13] "Rmpi"      "stats"     "graphics"  "grDevices" "utils"     "datasets" 
[19] "methods"   "base"     

> clusterEvalQ(cl,suppressMessages(library(data.table)))
[[1]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[2]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[3]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[4]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[5]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[6]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[7]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[8]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[9]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[10]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[11]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[12]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[13]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[14]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[15]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[16]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[17]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[18]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

[[19]]
 [1] "data.table" "tictoc"     "forcats"    "stringr"    "dplyr"     
 [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
[11] "tidyverse"  "igraph"     "snow"       "Rmpi"       "stats"     
[16] "graphics"   "grDevices"  "utils"      "datasets"   "methods"   
[21] "base"      

> clusterEvalQ(cl,suppressMessages(library(threejs)))
[[1]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[2]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[3]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[4]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[5]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[6]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[7]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[8]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[9]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[10]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[11]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[12]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[13]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[14]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[15]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[16]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[17]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[18]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

[[19]]
 [1] "threejs"    "data.table" "tictoc"     "forcats"    "stringr"   
 [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
[11] "ggplot2"    "tidyverse"  "igraph"     "snow"       "Rmpi"      
[16] "stats"      "graphics"   "grDevices"  "utils"      "datasets"  
[21] "methods"    "base"      

> clusterEvalQ(cl,suppressMessages(library(htmlwidgets)))
[[1]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[2]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[3]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[4]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[5]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[6]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[7]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[8]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[9]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[10]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[11]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[12]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[13]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[14]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[15]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[16]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[17]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[18]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

[[19]]
 [1] "htmlwidgets" "threejs"     "data.table"  "tictoc"      "forcats"    
 [6] "stringr"     "dplyr"       "purrr"       "readr"       "tidyr"      
[11] "tibble"      "ggplot2"     "tidyverse"   "igraph"      "snow"       
[16] "Rmpi"        "stats"       "graphics"    "grDevices"   "utils"      
[21] "datasets"    "methods"     "base"       

> clusterEvalQ(cl,suppressMessages(library(pbmcapply)))
[[1]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[2]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[3]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[4]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[5]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[6]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[7]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[8]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[9]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[10]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[11]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[12]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[13]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[14]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[15]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[16]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[17]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[18]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[19]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

> clusterEvalQ(cl,suppressMessages(library(parallel)))
[[1]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[2]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[3]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[4]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[5]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[6]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[7]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[8]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[9]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[10]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[11]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[12]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[13]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[14]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[15]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[16]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[17]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[18]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

[[19]]
 [1] "pbmcapply"   "parallel"    "htmlwidgets" "threejs"     "data.table" 
 [6] "tictoc"      "forcats"     "stringr"     "dplyr"       "purrr"      
[11] "readr"       "tidyr"       "tibble"      "ggplot2"     "tidyverse"  
[16] "igraph"      "snow"        "Rmpi"        "stats"       "graphics"   
[21] "grDevices"   "utils"       "datasets"    "methods"     "base"       

> 
> # We also need to export all our custom functions to all the slave nodes
> clusterEvalQ(cl,source("./Functions/GenerateStartingPoint.R"))
[[1]]
[[1]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (m_passdown = m, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape) 
{
    VertexNames <- as.character(1:(2 * m_passdown))
    VertexNamesA <- VertexNames[VertexNames[1]:median(as.numeric(VertexNames))]
    VertexNamesB <- VertexNames[(median(as.numeric(VertexNames)) + 
        1):(as.numeric(VertexNames[length(VertexNames)]) + 1)]
    EdgesA <- as.numeric(as.vector(combn(VertexNamesA, m = 2)))
    EdgesB <- as.numeric(as.vector(combn(VertexNamesB, m = 2)))
    StartingPoint <- graph(as.character(c(EdgesA, EdgesB)), directed = FALSE)
    V(StartingPoint)$demo <- c(rep(majority_passdown, m_passdown), 
        rep(minority_passdown, m_passdown))
    V(StartingPoint)$shape[V(StartingPoint)$demo == majority_passdown] <- majshape_passdown
    V(StartingPoint)$shape[V(StartingPoint)$demo == minority_passdown] <- minshape_passdown
    return(StartingPoint)
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/GeneratorFunction.R"))
[[1]]
[[1]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/NormInit.R"))
[[1]]
[[1]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (network, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    V(network)$norm <- seq_along(V(network))
    V(network)$norm[V(network)$demo == majority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        majority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_maj, (1 - network$norm_end_maj)), 
        replace = TRUE)
    V(network)$norm[V(network)$demo == minority_passdown] <- sample(length(V(network)$norm[V(network)$demo == 
        minority_passdown]), x = c(majnorm_passdown, minnorm_passdown), 
        prob = c(network$norm_end_min, (1 - network$norm_end_min)), 
        replace = TRUE)
    V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
    V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
    return(network)
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/SynchronousNormUpdateing.R"))
[[1]]
[[1]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        return(NewNorm)
    }
    NestedList <- list()
    for (n in 1:iter_passdown) {
        NewNorms <- sapply(names(V(network)), UpdateNorm)
        V(network)$norm <- NewNorms
        V(network)$color[V(network)$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)$color[V(network)$norm == minnorm_passdown] <- minnormcolor_passdown
        NestedList[[n]] <- network
    }
    return(NestedList)
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/GeneratorFunction.R"))
[[1]]
[[1]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (network, rhgcombinations_passdown = rhgCombinations, 
    AddingNodes = 96, m_passdown = m, t_passdown = t, p_passdown = p, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    h <- rhgcombinations_passdown[1, 2]
    g <- rhgcombinations_passdown[1, 1]
    if (length(V(network)$demo) == 0) {
        warning("Vertices need an attribute called group.")
        stop()
    }
    if (h < 0 | h > 1) {
        warning("parameter h must be between 0 and 1")
        stop()
    }
    if (m_passdown < 1 | m_passdown > length(V(network))) {
        warning("m needs to be larger than one but smaller or equal to the number of nodes in the initial network")
        stop()
    }
    for (i in 1:AddingNodes) {
        NewNodeName <- as.character(length(V(network)) + 1)
        NewVertex <- vertex(NewNodeName)
        NewDemo <- sample(c(minority_passdown, majority_passdown), 
            1, prob = c(g, (1 - g)))
        NewVertex$demo <- NewDemo
        Degrees <- degree(network)
        WeightedSameGroupNodeDegrees <- Degrees[V(network)$demo == 
            NewDemo] * h
        WeightedOtherGroupNodeDegrees <- Degrees[V(network)$demo != 
            NewDemo] * (1 - h)
        EdgeFormProb <- c(WeightedSameGroupNodeDegrees, WeightedOtherGroupNodeDegrees)/sum(Degrees[V(network)$demo == 
            NewDemo] * h, Degrees[V(network)$demo != NewDemo] * 
            (1 - h))
        EdgeFormProb <- EdgeFormProb[order(as.numeric(names(EdgeFormProb)))]
        ChosenNodes <- rep("String", m_passdown)
        for (i in 1:m_passdown) {
            EdgeFormProbUpdate <- EdgeFormProb[!is.element(names(EdgeFormProb), 
                ChosenNodes)]
            RandPick <- runif(n = 1, min = 0, max = max(cumsum(EdgeFormProbUpdate)))
            RoulettePick <- RandPick >= cumsum(EdgeFormProbUpdate)
            ChosenNodes[i] <- names(EdgeFormProbUpdate[sum(RoulettePick) + 
                1])
        }
        NewSenders <- rep(NewNodeName, length(ChosenNodes))
        EdgeList <- paste(NewSenders, ChosenNodes)
        EdgeList <- unlist(strsplit(EdgeList, " "))
        network <- network + NewVertex
        network <- network + edges(EdgeList)
        V(network)$shape[V(network)$demo == majority_passdown] <- majshape_passdown
        V(network)$shape[V(network)$demo == minority_passdown] <- minshape_passdown
    }
    network$h <- h
    network$g <- g
    network$t <- t_passdown
    network$m <- m_passdown
    return(network)
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/AsynchronousUpdateing.R"))
[[1]]
[[1]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (network, iter_passdown = iter, majority_passdown = majority, 
    minority_passdown = minority, majshape_passdown = majshape, 
    minshape_passdown = minshape, majnorm_passdown = majnorm, 
    minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    UpdateNorm <- function(node) {
        options(warn = -1)
        neighbors <- unlist(adjacent_vertices(network, node, 
            mode = "all"))
        neighbors <- strsplit(names(neighbors), ".", fixed = TRUE)
        neighbors <- sapply(neighbors, `[`, 2)
        NeighborGraph <- induced_subgraph(network, neighbors)
        PropTable <- sort(prop.table(table(V(NeighborGraph)$norm)), 
            decreasing = TRUE)
        PropTable <- PropTable[PropTable > V(network)[node]$t]
        if (length(PropTable) == 0) {
            NewNorm <- V(network)[node]$norm
        }
        else if (length(PropTable) == 1) {
            NewNorm <- names(PropTable[1])
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            1) {
            NewNorm <- names(sample(PropTable))[1]
        }
        else if (length(PropTable) == 2 & length(unique(PropTable)) == 
            2) {
            NewNorm <- names(PropTable[1])
        }
        else {
        }
        options(warn = 0)
        V(network)[node]$norm <- NewNorm
        V(network)[node]$color[V(network)[node]$norm == majnorm_passdown] <- majnormcolor_passdown
        V(network)[node]$color[V(network)[node]$norm == minnorm_passdown] <- minnormcolor_passdown
        return(network)
    }
    NestedList <- vector("list", iter_passdown + 1)
    NestedList[[1]] <- network
    for (n in 1:iter_passdown) {
        RandomOrder <- sample(V(network))
        for (i in RandomOrder) {
            network <- UpdateNorm(i)
        }
        if (identical(network, NestedList[[n]])) {
            (break)()
        }
        NestedList[[n + 1]] <- network
    }
    return(NestedList)
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/Extractor.R"))
[[1]]
[[1]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (y, majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    DemoDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NumberOfSameDemo <- sum(unlist(SameDemo))
        return(NumberOfSameDemo/nrow(DyadMat))
    }
    MajNormDyadBalance <- function(z) {
        MajGraph <- induced_subgraph(z, V(z)$demo == majority_passdown)
        DyadMat <- get.edgelist(MajGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MajGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MajResults <- sapply(y, MajNormDyadBalance)
    MinNormDyadBalance <- function(z) {
        MinGraph <- induced_subgraph(z, V(z)$demo == minority_passdown)
        DyadMat <- get.edgelist(MinGraph, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(MinGraph)[unlist(x)]$norm
        })
        SameNorm <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetList[unlist(SameNorm)], 
            paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/nrow(DyadMat)
        }
        Output <- c(nrow(DyadMat), PercentageOfSameNormMaj, PercentageOfSameNormMin)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesInMaj", "MajMajTies", "MinMinTies")
        return(Output)
    }
    MinResults <- sapply(y, MinNormDyadBalance)
    BetweenGroupDyadBalance <- function(z) {
        DyadMat <- get.edgelist(z, names = TRUE)
        DyadList <- lapply(seq_len(nrow(DyadMat)), function(i) DyadMat[i, 
            ])
        DyadNetList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$demo
        })
        DyadNetNormList <- lapply(DyadList, function(x) {
            V(z)[unlist(x)]$norm
        })
        SameDemo <- lapply(DyadNetList, function(x) {
            length(unique(unlist(x))) == 1
        })
        NormCombinations <- sapply(DyadNetNormList[unlist(SameDemo) != 
            TRUE], paste, collapse = " ")
        if (length(NormCombinations) == 0) {
            PercentageOfSameNormMaj <- 0
            PercentageOfSameNormMin <- 0
            PercentageofDiffNormMajMin <- 0
            PercentageofDiffNormMinMaj <- 0
        }
        else if (length(NormCombinations) != 0) {
            PercentageOfSameNormMaj <- table(NormCombinations)[paste(rep(majnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageOfSameNormMin <- table(NormCombinations)[paste(rep(minnorm_passdown, 
                2), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMajMin <- table(NormCombinations)[paste(c(majnorm_passdown, 
                minnorm_passdown), collapse = " ")]/length(NormCombinations)
            PercentageofDiffNormMinMaj <- table(NormCombinations)[paste(c(minnorm_passdown, 
                majnorm_passdown), collapse = " ")]/length(NormCombinations)
        }
        Output <- c(length(NormCombinations), PercentageOfSameNormMaj, 
            PercentageOfSameNormMin, PercentageofDiffNormMajMin, 
            PercentageofDiffNormMinMaj)
        Output[is.na(Output)] <- 0
        names(Output) <- c("TotalEdgesBetweenGroups", "%MajMajBetweenGroupTies", 
            "%MinMinBetweenGroupTies", "%MajMinBetweenGroupTies", 
            "%MinMajBetweenGroupTies")
        return(Output)
    }
    BetweenResults <- sapply(y, BetweenGroupDyadBalance)
    NoOfMajorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown])
    })
    NoOfMinorityNodes <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown])
    })
    NumberofEdgesInGraph <- sapply(y, function(x) {
        ecount(x)
    })
    TotalEdgesAmongMaj <- MajResults[1, 1]
    TotalEdgesAmongMin <- MinResults[1, 1]
    TotalEdgesBetweenGroups <- BetweenResults[1, 1]
    MajorityNormPercentageOverall <- sapply(y, function(x) {
        length(V(x)[V(x)$norm == majnorm_passdown])/vcount(x)
    })
    MajorityNormPercentageInMajority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == majority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == majority_passdown])
    })
    MajorityNormPercentageInMinority <- sapply(y, function(x) {
        length(V(x)[V(x)$demo == minority_passdown & V(x)$norm == 
            majnorm_passdown])/length(V(x)[V(x)$demo == minority_passdown])
    })
    PercSameGroupEdges <- sapply(y, DemoDyadBalance)
    PercMajMajEdgesInMaj <- MajResults[2, ]
    PercMinMinEdgesInMaj <- MajResults[3, ]
    PercMajMajEdgesInMin <- MinResults[2, ]
    PercMinMinEdgesInMin <- MinResults[3, ]
    PercMajMajEdgesBetween <- BetweenResults[2, ]
    PercMinMinEdgesBetween <- BetweenResults[3, ]
    PercMajMinEdgesBetween <- BetweenResults[4, ]
    PercMinMajEdgesBetween <- BetweenResults[5, ]
    NormDist1Net <- cbind.data.frame(NoOfMajorityNodes, NoOfMinorityNodes, 
        NumberofEdgesInGraph, TotalEdgesAmongMaj, TotalEdgesAmongMin, 
        TotalEdgesBetweenGroups, MajorityNormPercentageOverall, 
        MajorityNormPercentageInMajority, MajorityNormPercentageInMinority, 
        PercSameGroupEdges, PercMajMajEdgesInMaj, PercMinMinEdgesInMaj, 
        PercMajMajEdgesInMin, PercMinMinEdgesInMin, PercMajMajEdgesBetween, 
        PercMinMinEdgesBetween, PercMajMinEdgesBetween, PercMinMajEdgesBetween, 
        row.names = NULL)
    return(NormDist1Net)
    gc(verbose = TRUE)
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/Plotter.R"))
[[1]]
[[1]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (n, Slave_i = i, t_passdown = t, tmean_passdown = tmean, 
    tsd_passdown = tsd, OutputNetworkList_passdown = OutputNetworkList, 
    majority_passdown = majority, minority_passdown = minority, 
    majshape_passdown = majshape, minshape_passdown = minshape, 
    majnorm_passdown = majnorm, minnorm_passdown = minnorm, majnormcolor_passdown = majnormcolor, 
    minnormcolor_passdown = minnormcolor) 
{
    jpeg(paste0("Network_", Slave_i, "_Plot_", n, ".jpg"), quality = 100)
    set.seed(123)
    NetworkPlot <- plot(OutputNetworkList_passdown[[Slave_i]][[n]], 
        vertex.size = 10, vertex.color = V(OutputNetworkList_passdown[[Slave_i]][[n]])$color, 
        main = paste("Iteration ", n, "of network ", Slave_i))
    legend(x = "bottomleft", legend = c(paste(majority_passdown, 
        majnorm_passdown), paste(minority_passdown, majnorm_passdown), 
        paste(majority_passdown, minnorm_passdown), paste(minority_passdown, 
            minnorm_passdown)), col = c(majnormcolor_passdown, 
        majnormcolor_passdown, minnormcolor_passdown, minnormcolor_passdown), 
        pch = c(15, 16, 15, 16), xpd = TRUE, inset = c(-0.1, 
            -0.2), bty = "n")
    if (t_passdown == "uniform" | is.numeric(t_passdown)) {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    else if (t_passdown == "normal") {
        legend(x = "bottomright", legend = c(paste("pmaj = ", 
            OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_maj), 
            paste("pmin = ", OutputNetworkList_passdown[[Slave_i]][[n]]$norm_end_min), 
            paste("t = ", t_passdown, ";M = ", tmean_passdown, 
                ";SD = ", tsd_passdown), paste("m = ", OutputNetworkList_passdown[[Slave_i]][[n]]$m), 
            paste("g = ", OutputNetworkList_passdown[[Slave_i]][[n]]$g), 
            paste("h = ", OutputNetworkList_passdown[[Slave_i]][[n]]$h)), 
            xpd = TRUE, inset = c(0, -0.2), bty = "n")
    }
    dev.off()
    set.seed(Sys.time())
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/Animator2.R"))
[[1]]
[[1]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (NetList, Slave_i = i) 
{
    net.js <- NetList[[1]]
    net.js <- delete_vertex_attr(net.js, "color")
    staticLayout <- layout_with_fr(net.js, dim = 3)
    Animation <- graphjs(net.js, bg = "gray10", showLabels = F, 
        stroke = F, layout = replicate(length(NetList), staticLayout, 
            simplify = FALSE), vertex.color = lapply(NetList, 
            function(x) {
                V(x)$color
            }), main = as.list(rep(paste0("Network ", Slave_i), 
            length(NetList))))
    saveWidget(Animation, file = paste0("HTML_Network_Evolution_Animation_", 
        Slave_i, ".html"))
}

[[19]]$visible
[1] FALSE


> clusterEvalQ(cl,source("./Functions/removeNULLs.R"))
[[1]]
[[1]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[4]]$visible
[1] FALSE


[[5]]
[[5]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[5]]$visible
[1] FALSE


[[6]]
[[6]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[6]]$visible
[1] FALSE


[[7]]
[[7]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[7]]$visible
[1] FALSE


[[8]]
[[8]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[8]]$visible
[1] FALSE


[[9]]
[[9]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[9]]$visible
[1] FALSE


[[10]]
[[10]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[10]]$visible
[1] FALSE


[[11]]
[[11]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[11]]$visible
[1] FALSE


[[12]]
[[12]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[12]]$visible
[1] FALSE


[[13]]
[[13]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[13]]$visible
[1] FALSE


[[14]]
[[14]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[14]]$visible
[1] FALSE


[[15]]
[[15]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[15]]$visible
[1] FALSE


[[16]]
[[16]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[16]]$visible
[1] FALSE


[[17]]
[[17]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[17]]$visible
[1] FALSE


[[18]]
[[18]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[18]]$visible
[1] FALSE


[[19]]
[[19]]$value
function (x) 
{
    GetIndices <- function(y) {
        return(length(y) == 0)
    }
    if (sum(sapply(x, GetIndices)) > 0) {
        x <- x[-c(which(sapply(x, GetIndices)))]
    }
    else {
    }
    return(x)
}

[[19]]$visible
[1] FALSE


> 
> ############# Testing ParLapply() instead
> 
> 
> # Wrapper function for the whole process of:
> # - creating parameter permutations
> # - create folders and files to save output
> # - generate a list of basic networks as starting points
> # - evolve these starting points into larger networks based on parameters: node, m, g, h
> # - initilaize norm distributions within these networks based on parameters: norm_end_maj, norm_end_min
> # - simulate evolution of norms in these networks based on an adapted Granovetter Threshold Model, based on parameters: iter, t and UpdateProcess
> # - Extracting and saving distribution of norms at each iteration of each network
> # - OPTIONAL: Create Plots at each iteration of each network for visualization
> # - OPTIONAL: Create Animations from plots to visualize norm evolution in each network
> 
> Simulation <- function(
+   
+   ###### Setting interchangeable parameters for groups and norms #####
+   
+   majority = "majority",           # insert name for demographic attribute of majority
+   minority = "minority",           # insert name for demographic attribute of minority
+   
+   majshape = "square",             # insert shape to represent majority nodes in network graph
+   minshape = "circle",             # insert shape to represent minority nodes in network graph
+   
+   majnorm = "majority_norm",       # insert name for dominating norm in the majority group
+   minnorm = "minority_norm",       # insert name for dominating norm in the minority group
+   
+   majnormcolor = "lightblue",      # insert color to represent norm that dominates in majority group
+   minnormcolor = "lightcoral",     # insert color to represent norm that dominates in minority group
+   
+   
+   ##### Simulation Parameters ######
+   
+   ## Stable Parameters
+   r = 1,                            # number of runs per condition
+   nodes = 10,                      # number of nodes in network
+   iter = 20,                        # Number of Iterations for the Granovetter Threshold Model (In the final version, we should implement automatic conversion detection to speed it up)
+   
+   ## varying parameters (some of these can handle sequences)
+   
+   norm_end_maj = 0.7,               # proportion of majority group that endorses majority norm 
+   norm_end_min = 0.3,               # proportion of minority group that endorses majority norm
+   t = "uniform",                    # threshold value for the Granovetter Threshold Model supports single value between 0 and 1, "uniform" and "normal" (trimmed to 0 - 1)
+   tmean = NA,                       # when t is supposed to come from a normal distribution, we need to specify a value for its mean
+   tsd = NA,                         # when t is supposed to come from a norms distribution, we need to specify a value for its sd    
+   m = 2,                            # value for minimum degree (SEQUENCE NOT IMPLEMENTED YET)
+   g = seq(0,0.5,0.5),               # proportion of network that's in the minority group      
+   h = seq(0,1,0.5),                 # homophily
+   
+   ##### Simulation Settings #####
+   
+   UpdateProcess = "asynchronous",   # controls whether nodes are updated synchronously or asynchrounously
+   
+   # Technical Settings
+   
+   cores = 1,                        # controls how many cores to use (For Windows, only one core is supported)
+   
+   # Output Settings
+   
+   CreatePlots = FALSE,              # controls whether the function does create and save a plot of every network iteration (Time consuming)
+   AnimatePlots = FALSE,             # controls whether all iteration plots of all networks are summarized into a GIF showcasing network evolution (VERY time consuming)
+   
+   # Settings for special cases
+   SimplifyCombinations = FALSE      # only allows for specific complementary combinations of norm_end_maj and norm_end_min
+   
+ ) {
+   
+   options(warn = -1)
+   
+   ## importing packages
+   if("igraph" %in% installed.packages() != TRUE) {
+     install.packages("igraph")
+   }
+   if("tidyverse" %in% installed.packages() != TRUE) {
+     install.packages("tidyverse")
+   }
+   if("tictoc" %in% installed.packages() != TRUE) {
+     install.packages("tictoc")
+   }
+   if("parallel" %in% installed.packages() != TRUE) {
+     install.packages("parallel")
+   }
+   if("data.table" %in% installed.packages() != TRUE) {
+     install.packages("data.table")
+   }
+   if("threejs" %in% installed.packages() != TRUE) {
+     install.packages("threejs")
+   }
+   if("htmlwidgets" %in% installed.packages() != TRUE) {
+     install.packages("htmlwidgets")
+   }
+   if("pbmcapply" %in% installed.packages() != TRUE) {
+     install.packages("pbmcapply")
+   }
+   
+   
+   ## attaching packages while surpressing console print messages
+   suppressMessages(library(igraph))
+   suppressMessages(library(tidyverse))
+   suppressMessages(library(tictoc))
+   suppressMessages(library(parallel))
+   suppressMessages(library(data.table))
+   suppressMessages(library(threejs))
+   suppressMessages(library(htmlwidgets))
+   suppressMessages(library(pbmcapply))
+   
+   # Switching warnings back on
+   options(warn = 0)
+   
+   # Taking the time for overall simulation
+   tic("\n \n \t \t-----------------FINISHED SIMULATION-------------------")
+   
+   # Taking Time for Setup
+   tic("Setup completed")
+   
+   cat("Setup:\n")
+   
+   # check if input is valid
+   if(majority == minority |
+      majshape == minshape |
+      majnorm  == minnorm  |
+      majnormcolor == minnormcolor){
+     
+     warning("Input for demographic and norm attributes must be different between the tw groups")
+     stop()
+     
+   }
+   
+   cat("\t - Validity of input checked \n")
+   
+   # detecting operating system to set cores to 1 for windows systems
+   if (.Platform$OS.type == "windows" & cores != 1) {
+     
+     cores = 1
+     warning("Windows Operating System detected. Multiple Cores are not supported in Windows. Simulation will continue with 1 core")
+     
+   } else {
+     
+     cores = cores
+   }
+   
+   cat("\t - Number of used cores adapted to operating system \n")
+   
+   ## checking if we have write permissions to the wd
+   if(file.access(getwd(),2) != 0) {
+     
+     cat("No write permission in the current working directory\n")
+     stop()
+   }
+   
+   cat("\t - Verified writing permissions to working directory \n")
+   
+   # Creating Output table for specified parameter range
+   expand.grid(nodes,iter,norm_end_maj,norm_end_min,t,m,g,h,1:r) %>%
+     rename(nodes = Var1) %>%
+     rename(iter = Var2) %>%
+     rename(norm_end_maj = Var3) %>%
+     rename(norm_end_min = Var4) %>%
+     rename(t = Var5) %>%
+     rename(m = Var6) %>%
+     rename(g = Var7) %>%
+     rename(h = Var8) %>%
+     rename(RunWithinParameterSet = Var9) %>%
+     mutate(Diameter = NA,
+            PercentMajorityGroup = NA,
+            NumberIterationsRun = NA,
+            Assortativity = NA,
+            DegreeCentrality = NA,
+            ClosenessCentrality = NA,
+            BetweennessCentrality = NA,
+            Clusters = NA,
+            MajNormProbInMaj = NA,
+            MajNormProbInMin = NA,
+            TimeDone = NA) ->
+     OutputDataTable
+   
+   cat("\t - Finished creation of parameter permutation table \n")
+   
+   # Simplify Combinations
+   if(SimplifyCombinations == TRUE){
+     
+     OutputDataTable <- OutputDataTable[(OutputDataTable$norm_end_maj == 0.5 & OutputDataTable$norm_end_min == 0.5) |
+                                          (OutputDataTable$norm_end_maj == 0.6 & OutputDataTable$norm_end_min == 0.4) |
+                                          (OutputDataTable$norm_end_maj == 0.8 & OutputDataTable$norm_end_min == 0.2),]
+     
+   }
+   
+   
+   # loading all necessary functions
+   source("./Functions/GenerateStartingPoint.R")
+   source("./Functions/GeneratorFunction.R")
+   source("./Functions/NormInit.R")
+   source("./Functions/SynchronousNormUpdateing.R")
+   source("./Functions/AsynchronousUpdateing.R")
+   source("./Functions/Extractor.R")
+   source("./Functions/Plotter.R")
+   source("./Functions/Animator2.R")
+   source("./Functions/Animator.R")
+   source("./Functions/removeNULLs.R")
+   
+   cat("\t - Sourced necessary functions \n")
+   
+   ### Create new folder for output and saving parameter combinations
+   
+   # saving old working directory
+   oldwd <- getwd()
+   
+   # creating a new folder to save output in
+   dir.create(paste(oldwd, "/Output",sep=""), showWarnings = F)
+   
+   # setting new folder as working directory
+   setwd(paste(oldwd, "/Output",sep=""))
+   
+   # saving all permutations in a seperate Data object
+   write.csv(OutputDataTable[,1:8], file = "ParameterPermutations.csv")
+   
+   # cat Status
+   cat(paste("\t - Created output folder at", paste(oldwd, "/Output","\n",sep="")))
+   
+   # Generate Starting Point Network
+   StartingPoint <- GenerateStartingPoint(m_passdown = m,
+                                          majority_passdown = majority,
+                                          minority_passdown = minority,
+                                          majshape_passdown = majshape,
+                                          minshape_passdown = minshape)
+   
+   cat("\t - Finished generation of starting point network \n \n")
+   
+   # output Setup completed + time
+   toc()
+   
+   cat("\n \n Creating Network Structure & Initializing Norms: \n")
+   
+   #### Run the Actual Simulation
+   
+   # taking time for creation of network structure
+   tic("Finished creation of Network Structures")
+   
+   # transforming output table into list
+   rhgCombinations <- split(OutputDataTable[,7:8], seq(nrow(OutputDataTable[,7:8])))
+   
+   # Generating List of Networks from Starting Point Network by adding
+   # We generate r number of networks for each combination of h and g
+   
+   NetworkList <- parLapply(cl,
+                             rhgCombinations,
+                             NetworkGeneration,
+                             m_passdown = m,
+                             network=StartingPoint,
+                             AddingNodes=nodes-2*m,
+                             t_passdown = t,
+                             majority_passdown = majority,
+                             minority_passdown = minority,
+                             majshape_passdown = majshape,
+                             minshape_passdown = minshape,
+                             majnorm_passdown = majnorm,
+                             minnorm_passdown = minnorm,
+                             majnormcolor_passdown = majnormcolor,
+                             minnormcolor_passdown = minnormcolor)
+   
+   # Output Finished creation of network structures + time
+   toc()
+   
+   # taking time for initialization of norms
+   tic("Finished Initialization of Norms in all Networks")
+   
+   # We attach the majority group proportion parameter as an attribute of each network so we can pass them simultaneously
+   # to the norm initialization function
+   
+   tic("Finished attaching majority norm endorsement to networks")
+   AttachedMajGroupProp <- clusterMap(cl,set.graph.attribute,NetworkList,name = "norm_end_maj",value = OutputDataTable[,3])
+   toc()
+   
+   tic("Finished attaching minority norm endorsement to networks")
+   NormNetworkList <- clusterMap(cl,set.graph.attribute,AttachedMajGroupProp,name = "norm_end_min",value = OutputDataTable[,4])
+   toc()
+   
+   # Initilaizing base norm norm distribution based on passed parameters
+   NormNetworks <- parLapply(cl,
+                              NormNetworkList,
+                              NormInit,
+                              majority_passdown = majority,
+                              minority_passdown = minority,
+                              majshape_passdown = majshape,
+                              minshape_passdown = minshape,
+                              majnorm_passdown = majnorm,
+                              minnorm_passdown = minnorm,
+                              majnormcolor_passdown = majnormcolor,
+                              minnormcolor_passdown = minnormcolor)
+   toc()
+   
+   cat("\n \n Granovetter Threshold Model - Norm Evolution:\n")
+   
+   # Granovetter Threshold Model
+   
+   # if t is a single numeric value, we assign each node in each network the attribute of said value
+   # if it is uniform or normal, we generate the appropriate values for each network.
+   if(is.numeric(t) & t <= 1 & t >= 0){
+     
+     # assigning every node in every network the same specified value
+     tic("Finished assigning treshold values to nodes")
+     NormInitNetworks <- parLapply(cl,
+                                   NormNetworks,
+                                   function(x, t_passdown){V(x)$t <- t_passdown; return(x)},
+                                   t)
+     # output info + time
+     toc()
+     
+   } else if (t == "uniform"){
+     
+     # assigning random uniform values to all nodes in all networks
+     tic("Finished assigning treshold values to nodes")
+     NormInitNetworks <- parLapply(cl,
+                                   NormNetworks,
+                                   function(x){V(x)$t <- runif(length(V(x)),0,1); return(x)}) 
+     # output info + time
+     toc()
+     
+   } else if (t == "normal"){
+     
+     # assigning random values from a normal distribution to all nodes in all networks determined by parameters tmean and tsd
+     tic("Finished assigning trehsold values to nodes")
+     NormInitNetworks <- parLapply(cl,
+                                    NormNetworks,
+                                    function(x,tmeanpd,tsdpd){Values <- rnorm(length(V(x)),tmeanpd,tsdpd)
+                                    Values[Values>1] <- 1
+                                    Values[Values<0] <- 0
+                                    V(x)$t <- Values
+                                    return(x)
+                                    },
+                                    tmean,tsd) 
+     
+     # output info + time
+     toc()
+   }
+   
+   
+   # Norm Updateing function using the Granovetter Threshold Model (saves every step of every model)
+   
+   if(UpdateProcess == "asynchronous"){
+     
+     # taking time for norm evolution
+     tic("Finished Simulation of Norm Evolution in all networks")
+     
+     OutputNetworkList <- parLapply(cl,
+                                    NormInitNetworks,
+                                     AsynchronousUpdateing,
+                                     iter_passdown = iter,
+                                     majority_passdown = majority,
+                                     minority_passdown = minority,
+                                     majshape_passdown = majshape,
+                                     minshape_passdown = minshape,
+                                     majnorm_passdown = majnorm,
+                                     minnorm_passdown = minnorm,
+                                     majnormcolor_passdown = majnormcolor,
+                                     minnormcolor_passdown = minnormcolor)
+     
+     # print timing and finish message
+     toc()
+     
+     # removing NULL elements from the list (introduced trough breaking the function when attributes reached equilibrium)
+     tic("Finished removing Null elements from network list \n \n")
+     OutputNetworkList <- parLapply(cl,OutputNetworkList,removeNULLs)
+     toc()
+     
+   } else if(UpdateProcess == "synchronous"){
+     
+     # taking time for norm evolution
+     tic("Finished Simulation of Norm Evolution in all networks")
+     
+     OutputNetworkList <- parLapply(cl,
+                                    NormInitNetworks,
+                                     SynchronousNormUpdateing,
+                                     iter_passdown = iter,
+                                     majority_passdown = majority,
+                                     minority_passdown = minority,
+                                     majshape_passdown = majshape,
+                                     minshape_passdown = minshape,
+                                     majnorm_passdown = majnorm,
+                                     minnorm_passdown = minnorm,
+                                     majnormcolor_passdown = majnormcolor,
+                                     minnormcolor_passdown = minnormcolor)
+     
+     toc()
+     
+     # removing NULL elements from the list (introduced trough breaking the function when attributes reached equilibrium)
+     tic("Finished removing Null elements from network list")
+     OutputNetworkList <- parLapply(cl,OutputNetworkList,removeNULLs)
+     toc()
+   }
+   
+   # saving the cleaned up Output Network list
+   save(OutputNetworkList,file="OutputNetworkList.Rdata")
+   
+   # printing info
+   cat("Extracting Distribution of Norms from Network Objects: \n")
+   
+   # taking time
+   tic("Extracted distribution of Norms for all Networks")
+   
+   # Applying the extractor function to the list of all networks
+   NormResults <- parLapply(cl,
+                            OutputNetworkList,
+                             Extractor,
+                             majority_passdown = majority,
+                             minority_passdown = minority,
+                             majshape_passdown = majshape,
+                             minshape_passdown = minshape,
+                             majnorm_passdown = majnorm,
+                             minnorm_passdown = minnorm,
+                             majnormcolor_passdown = majnormcolor,
+                             minnormcolor_passdown = minnormcolor)
+   
+   # print that data extraction if finished + time
+   toc()
+   
+   # taking time
+   tic("Finished creation of network feature dataframe")
+   
+   # We want to create an output file that gives us the distribution of norms in the groups at each iteration
+   
+   # First we need a vector that tells us how many iterations each model ran (e.g. how many networks we have for each line
+   # in the perumatation table)
+   IterationCounts <- sapply(NormResults,function(x){dim(x)[1]},USE.NAMES = FALSE)
+   names(IterationCounts) <- NULL
+   
+   # Then we have to repeat the rows of the Permutation Parameter Dataframe as many times as we did iterations for
+   # the parameter permutation
+   OutputData <- OutputDataTable[,1:8]
+   n.times <- IterationCounts
+   OutputData <- OutputData[rep(seq_len(nrow(OutputData)), n.times),] # Sometimes we get an error in this step?
+   # The error occurs because the network list structure is broken -> have a look at that -> Step by step!
+   
+   # we want an indicator for the iteration number
+   IterationNumberList <- sapply(rownames(OutputData),strsplit,".",fixed=TRUE)
+   IterationNumberSplit <- unlist(sapply(IterationNumberList,`[`,2))
+   names(IterationNumberSplit) <- NULL
+   IterationNumber <- as.numeric(IterationNumberSplit)
+   IterationNumber[is.na(IterationNumber)] <- 0
+   
+   # and for the network number
+   NetworkNumberList <- sapply(rownames(OutputData),strsplit,".",fixed=TRUE)
+   NetworkNumberSplit <- unlist(sapply(IterationNumberList,`[`,1))
+   names(NetworkNumberSplit) <- NULL
+   NetworkNumber <- as.numeric(NetworkNumberSplit)
+   
+   # We now need to bind the iteration number to the output dataframe
+   OutputData <- cbind.data.frame(OutputData,NetworkNumber)
+   OutputData <- cbind.data.frame(OutputData,IterationNumber)
+   OutputData <- OutputData[c("NetworkNumber","IterationNumber","nodes","iter","norm_end_maj","norm_end_min","t","m","g","h")]
+   
+   # next we convert the list of dataframes into a single dataframe
+   CompleteNormsDF <- do.call("rbind", NormResults)
+   
+   # and attach it to the output data file
+   Output <- cbind.data.frame(OutputData,CompleteNormsDF)
+   
+   # saving
+   save(Output, file = "NormResultsDF.RData")
+   
+   # end time for data frame
+   toc()
+   
+   # ensuring that we also create the plots when the animation is desired
+   if(AnimatePlots == TRUE & CreatePlots == FALSE){
+     
+     CreatePlots <- TRUE
+     
+   }
+   
+   # creating plots for all iterations of all networks if desired
+   if(CreatePlots == TRUE){
+     
+     cat("Creating Network Plots: \n")
+     
+     # setting the current directory as the main directory to create subdirectories
+     mainDir <- getwd()
+     
+     # taking the time
+     tic("Finished plotting of all Networks")
+     
+     # creating as many subdirectories as we have Networks in the outputNetworkList
+     for(i in 1:length(OutputNetworkList)){
+       
+       # list of subdirs
+       subDir <- paste("OutputPlots",i,sep="")
+       
+       # creating folders
+       if (file.exists(subDir)){
+         warning("file or folder already exists")
+         stop()
+       } else {
+         dir.create(file.path(mainDir,subDir))
+         setwd(mainDir)
+       }
+       
+       # go to subdir
+       CurrDir <- paste0(mainDir,"/",subDir)
+       setwd(CurrDir)
+       
+       # For each element of the outputnetworklist, plot every iteration and save it in the corresponding folder
+       parLapply(cl,
+                 seq_along(OutputNetworkList[[i]]),
+                  Plotter,
+                  Slave_i = i,
+                  t_passdown = t,
+                  tmean_passdown = tmean,
+                  tsd_passdown = tsd,
+                  OutputNetworkList_passdown = OutputNetworkList,
+                  majority_passdown = majority,
+                  minority_passdown = minority,
+                  majshape_passdown = majshape,
+                  minshape_passdown = minshape,
+                  majnorm_passdown = majnorm,
+                  minnorm_passdown = minnorm,
+                  majnormcolor_passdown = majnormcolor,
+                  minnormcolor_passdown = minnormcolor)
+       
+       # We don´t need this if we´re using the pbmclapply progress bar
+       # cat(paste("Finished all Plots for Network",i,"of",length(OutputNetworkList)))
+       
+       # going up from the subdirectory again
+       setwd('..')
+     }
+     
+     # outputting time
+     toc()
+     
+     # cat exit
+     cat("Finished Simulation, Analysis and Plotting of Networks\n")
+   }
+   
+   # creating animations from generated plots if desired
+   if(AnimatePlots == TRUE){
+     
+     # printing info
+     cat("Creating Animations of Network Plots:\n")
+     
+     # taking time
+     tic("Finished all Animations of all Network Plots:")
+     
+     # going to output folder
+     # setwd(paste0(getwd(),"/Output"))
+     
+     # Creating new directory
+     dir.create("Animations")
+     
+     # going into animation folder
+     setwd(paste0(getwd(),"/Animations"))
+     
+     # looping through all network configurations
+     for(i in 1:length(OutputNetworkList)){
+       
+       Animator2(OutputNetworkList[[i]],Slave_i = i)
+       
+       # creating animations
+       # pbmclapply(OutputNetworkList[[i]],
+       #            Animator2,
+       #            Slave_i = i,
+       #            mc.cores= cores)
+       # 
+     }
+     
+     
+     # going into the proper directory again
+     setwd('..')
+     setwd('..')
+     
+     # outputting time
+     toc()
+     
+     # cat exit
+     cat("-------------------SIMULATION, ANALYSIS PLOTTING & ANIMATION FINISHED---------------\n")
+     
+   }
+   
+   # end time for simulation
+   toc()
+   
+   # going back to original wd
+   setwd(oldwd)
+ }
> 
> 
> 
> # setting the amount of cores // THIS DOES NOT WORK ON MPI CLUSTERS!
> #CoreAmount <- detectCores()
> #cat(CoreAmount)
> 
> # sourcing function
> # source("Simulation.R")
> 
> # run with specific parameters // SIMULATION RELIES ON MCLAPPLY; THIS DOESNT WORK FOR MPI CLUSTERS
> Simulation(nodes = 2000,
+            r = 20,
+            g = 0.5,
+            h = 0.5,
+            iter = 10000,
+            cores = mpi.universe.size())
Setup:
	 - Validity of input checked 
	 - Number of used cores adapted to operating system 
	 - Verified writing permissions to working directory 
	 - Finished creation of parameter permutation table 
	 - Sourced necessary functions 
	 - Created output folder at /home/fkarimi2/SimulatingNormativeConflict/Output
	 - Finished generation of starting point network 
 
Setup completed: 0.118 sec elapsed

 
 Creating Network Structure & Initializing Norms: 
Finished creation of Network Structures: 28.353 sec elapsed
Finished attaching majority norm endorsement to networks: 1.67 sec elapsed
Finished attaching minority norm endorsement to networks: 1.772 sec elapsed
Finished Initialization of Norms in all Networks: 5.164 sec elapsed

 
 Granovetter Threshold Model - Norm Evolution:
Finished assigning treshold values to nodes: 6.23 sec elapsed

real	2951m24.235s
user	5850m37.440s
sys	22m30.630s
