}
}
a <- AssignPrefList(1);a
V(graph)[1]$PrefList
AssignPrefList <- function(x){
if(V(graph)[x]$gender == "male"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "female"]))
}
if(V(graph)[x]$gender == "female"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "male"]))
}
return(PrefList)
}
a <- AssignPrefList(1);a
a <- AssignPrefList(16);a
sapply(1:x,AssignPrefList)
sapply(as.character(V(graph)),AssignPrefList)
t(sapply(as.character(V(graph)),AssignPrefList))
V(graph)$PrefList
delete_vertex_attr(graph, "PrefList")
V(graph)$PrefList
delete_vertex_attr(graph, "PrefList")
V(graph)$PrefList
V(graph)$B
for (i in 1:x){
print(i)
}
V(graph)["1"]$PrefList
V(graph)["1"]$PrefList <- NULL
rm(lsit=ls())
rm(list=ls())
loading libraries
library(igraph)
# creating nodes with gender attributes
x <- 30
graph <- make_empty_graph() + vertices(as.character(1:x))
plot(graph)
# assigning gender attribute to nodes 50/50
V(graph)[1:(x/2)]$gender <- "male"
V(graph)[((x/2)+1):max(x)]$gender <- "female"
# assigning preferences
AssignPrefList <- function(x){
if(V(graph)[x]$gender == "male"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "female"]))
}
if(V(graph)[x]$gender == "female"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "male"]))
}
return(PrefList)
}
# Matrix of preference vectors for each node
PrefMat <- t(sapply(as.character(V(graph)),AssignPrefList))
V(graph)["1"]
V(graph)["1"]$PrefList
V(graph)["1"]$PrefList <- list(PrefMat[1,])
V(graph)["1"]$PrefList
V(graph)["1"]$PrefList[1]
V(graph)["1"]$PrefList[[1]][1]
V(graph)$PrefList
for (i in 1:x){
V(graph)[as.character(i)]$PrefList <- list(PrefMat[i,])
}
V(graph)$PrefList
V(graph)["2"]$test <- c(1,2,3)
V(graph)["2"]$test
V(graph)["2"]$test <- list(c(1,2,3))
V(graph)["2"]$test
V(graph)$PrefList
V(graph)[V(graph)$gender == "female"]
V(graph)[V(graph)$gender == "female"]$PrefList
sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[")
sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)
V(graph)[V(graph)$gender == "female"]$PrefList
V(graph)[V(graph)$gender == "female"]
sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)
c(rbind(as.character(V(graph)[V(graph)$gender == "female"]),
sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)))
# creating edgelist for all female nodes with their first preferences
FirstProposals <- c(rbind(as.character(V(graph)[V(graph)$gender == "female"]), sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)))
FirstPropGraph <- add_edges(graph, FirstProposals)
plot(FirstPropGraph)
plot(FirstPropGraph, directed = TRUE)
# men evaluating proposals
V(FirstPropGraph)["1"]
# men evaluating proposals
E(FirstPropGraph)["1"]
# men evaluating proposals
V(FirstPropGraph)["1"]
adjacent_vertices(graph, V(FirstPropGraph)["1"])
adjacent_vertices(FirstPropGraph, V(FirstPropGraph)["1"])
adjacent_vertices(FirstPropGraph, V(FirstPropGraph)[1])
adjacent_vertices(FirstPropGraph, "1")
adjacent_vertices(FirstPropGraph, 1)
adjacent_vertices(FirstPropGraph, 1:30)
adjacent_vertices(FirstPropGraph, 1:30, mode="all")
V(FirstPropGraph)["1"]$PrefList
# getting all connections for one node
as.character(adjacent_vertices(FirstPropGraph, 1:30, mode="all"))
# getting all connections for one node
adjacent_vertices(FirstPropGraph, 1:30, mode="all")
# getting all connections for one node
adjacent_vertices(FirstPropGraph, "1", mode="all")
# getting all connections for one node
as.character(adjacent_vertices(FirstPropGraph, "1", mode="all"))
# getting all connections for one node
V(adjacent_vertices(FirstPropGraph, "1", mode="all"))
# getting all connections for one node
unlist(adjacent_vertices(FirstPropGraph, "1", mode="all"))
names(A) <- NULL;A
# getting all connections for one node
A <- unlist(adjacent_vertices(FirstPropGraph, "1", mode="all"))
names(A) <- NULL;A
# getting ranks in PrefList of that node for the connected ones
match(A,V(FirstPropGraph)["1"]$PrefList)
V(FirstPropGraph)["1"]$PrefList
# getting ranks in PrefList of that node for the connected ones
match(A,unlist(V(FirstPropGraph)["1"]$PrefList))
# picking the proposing women that is the heighest in the PrefList
match(A,unlist(V(FirstPropGraph)["1"]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)["1"]$PrefList)))
A[match(A,unlist(V(FirstPropGraph)["1"]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)["1"]$PrefList)))]
A <- as.character(A[match(A,unlist(V(FirstPropGraph)["1"]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)["1"]$PrefList)))])
# saving edge
edge <- c("1",A)
edge
V(FirstPropGraph)[V(FirstPropGraph) == "male"]
V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"]
as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"])
MaleChoice <- function(x){
# getting all connections for one node
A <- unlist(adjacent_vertices(FirstPropGraph, x, mode="all"))
names(A) <- NULL;A
# getting ranks in PrefList of that node for the connected ones
match(A,unlist(V(FirstPropGraph)[x]$PrefList))
# picking the proposing women that is the heighest in the PrefList
match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))
A <- as.character(A[match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))])
# saving edge
edge <- c(x,A)
}
lapply(as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"]),MaleChoice)
warnings()
unlist(adjacent_vertices(FirstPropGraph, "2", mode="all"))
MaleChoice <- function(x){
# getting all connections for one node
A <- unlist(adjacent_vertices(FirstPropGraph, x, mode="all"))
names(A) <- NULL;A
if(length(A) == 0){
edge <- c(NA,NA)
} else {
# getting ranks in PrefList of that node for the connected ones
match(A,unlist(V(FirstPropGraph)[x]$PrefList))
# picking the proposing women that is the heighest in the PrefList
match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))
A <- as.character(A[match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))])
# saving edge
edge <- c(x,A)
}
return(edge)
}
lapply(as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"]),MaleChoice)
B <- lapply(as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"]),MaleChoice);B
unlist(B)
B <- unlist(B)
B[is.na(B) == FALSE]
MaleChoiceEdges <- B[is.na(B) == FALSE]
# deleting all edges
MaleChoiceGraph <- FirstPropGraph
delete.edges(MaleChoiceGraph)
delete.edges(MaleChoiceGraph, E(MaleChoiceGraph))
MaleChoiceGraph <-add_edges(MaleChoiceGraph,MaleChoiceEdges)
plot(MaleChoiceGraph)
# deleting all edges
MaleChoiceGraph <- FirstPropGraph
delete.edges(MaleChoiceGraph, E(MaleChoiceGraph))
MaleChoiceGraph <-add_edges(MaleChoiceGraph,MaleChoiceEdges)
plot(MaleChoiceGraph)
# deleting all edges
MaleChoiceGraph <- FirstPropGraph
# deleting all edges
MaleChoiceGraph <- FirstPropGraph
MaleChoiceGraph <- delete.edges(MaleChoiceGraph, E(MaleChoiceGraph))
MaleChoiceGraph <-add_edges(MaleChoiceGraph,MaleChoiceEdges)
plot(MaleChoiceGraph)
# assigning color to nodes based on gender
V(graph)[V(graph)$gender == "male"]$color <- "lightblue"
V(graph)[V(graph)$gender == "male"]$color <- "lightcoral"
rm(list=ls())
# loading libraries
library(igraph)
# creating nodes with gender attributes
x <- 30
graph <- make_empty_graph() + vertices(as.character(1:x))
plot(graph)
# assigning gender attribute to nodes 50/50 (we wanna randomize this later so order doesn,t matter)
V(graph)[1:(x/2)]$gender <- "male"
V(graph)[((x/2)+1):max(x)]$gender <- "female"
# assigning color to nodes based on gender
V(graph)[V(graph)$gender == "male"]$color <- "lightblue"
V(graph)[V(graph)$gender == "male"]$color <- "lightcoral"
plot(graph)
# loading libraries
library(igraph)
############## Generating graph object #############
# creating nodes with gender attributes
x <- 30
graph <- make_empty_graph() + vertices(as.character(1:x))
plot(graph)
# assigning gender attribute to nodes 50/50 (we wanna randomize this later so order doesn,t matter)
V(graph)[1:(x/2)]$gender <- "male"
V(graph)[((x/2)+1):max(x)]$gender <- "female"
# assigning color to nodes based on gender
V(graph)[V(graph)$gender == "male"]$color <- "skyblue"
V(graph)[V(graph)$gender == "male"]$color <- "lightcoral"
plot(graph)
library(igraph)
############## Generating graph object #############
# creating nodes with gender attributes
x <- 30
graph <- make_empty_graph() + vertices(as.character(1:x))
plot(graph)
# assigning gender attribute to nodes 50/50 (we wanna randomize this later so order doesn,t matter)
V(graph)[1:(x/2)]$gender <- "male"
V(graph)[((x/2)+1):max(x)]$gender <- "female"
# assigning color to nodes based on gender
V(graph)[V(graph)$gender == "male"]$color <- "skyblue"
V(graph)[V(graph)$gender == "female"]$color <- "lightcoral"
plot(graph)
# assigning preferences
AssignPrefList <- function(x){
if(V(graph)[x]$gender == "male"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "female"]))
}
if(V(graph)[x]$gender == "female"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "male"]))
}
return(PrefList)
}
# Matrix of preference vectors for each node
PrefMat <- t(sapply(as.character(V(graph)),AssignPrefList))
# Attaching PrefList as a node attribute to each node
for (i in 1:x){
V(graph)[as.character(i)]$PrefList <- list(PrefMat[i,])
}
# Women proposing for the first time
V(graph)[V(graph)$gender == "female"]
V(graph)[V(graph)$gender == "female"]$PrefList
sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)
V(graph)$PrefList
# creating edgelist for all female nodes with their first preferences
FirstProposals <- c(rbind(as.character(V(graph)[V(graph)$gender == "female"]), sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)))
FirstPropGraph <- add_edges(graph, FirstProposals)
plot(FirstPropGraph, directed = TRUE)
unlist(adjacent_vertices(FirstPropGraph, "2", mode="all"))
as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"])
MaleChoice <- function(x){
# getting all connections for one node
A <- unlist(adjacent_vertices(FirstPropGraph, x, mode="all"))
names(A) <- NULL;A
if(length(A) == 0){
edge <- c(NA,NA)
} else {
# getting ranks in PrefList of that node for the connected ones
match(A,unlist(V(FirstPropGraph)[x]$PrefList))
# picking the proposing women that is the heighest in the PrefList
match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))
A <- as.character(A[match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))])
# saving edge
edge <- c(x,A)
}
return(edge)
}
B <- lapply(as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"]),MaleChoice);B
B <- unlist(B)
MaleChoiceEdges <- B[is.na(B) == FALSE]
# deleting old edges
MaleChoiceGraph <- FirstPropGraph
MaleChoiceGraph <- delete.edges(MaleChoiceGraph, E(MaleChoiceGraph))
# adding new edges + plotting
MaleChoiceGraph <-add_edges(MaleChoiceGraph,MaleChoiceEdges)
plot(MaleChoiceGraph)
adjacent_vertices(FirstPropGraph, V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"], mode="all")
V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]
adjacent_vertices(FirstPropGraph, as.character(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]), mode="all")
adjacent_vertices(MaleChoiceGraph, as.character(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]), mode="all")
length(adjacent_vertices(MaleChoiceGraph, as.character(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]), mode="all"))
unlist(adjacent_vertices(MaleChoiceGraph, as.character(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]), mode="all"))
degree(MaleChoiceGraph
degree(MaleChoiceGraph)
degree(MaleChoiceGraph)
degree(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]
degree(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"])
degree(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"])
V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]$degree
degree(MaleChoiceGraph,V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"])
rm(list=ls())
# loading libraries
library(igraph)
# creating nodes with gender attributes
x <- 30
graph <- make_empty_graph() + vertices(as.character(1:x))
plot(graph)
# assigning gender attribute to nodes 50/50 (we wanna randomize this later so order doesn,t matter)
V(graph)[1:(x/2)]$gender <- "male"
V(graph)[((x/2)+1):max(x)]$gender <- "female"
# assigning color to nodes based on gender
V(graph)[V(graph)$gender == "male"]$color <- "skyblue"
V(graph)[V(graph)$gender == "female"]$color <- "lightcoral"
plot(graph)
# assigning preferences
AssignPrefList <- function(x){
if(V(graph)[x]$gender == "male"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "female"]))
}
if(V(graph)[x]$gender == "female"){
PrefList <- as.character(sample(V(graph)[V(graph)$gender == "male"]))
}
return(PrefList)
}
# Matrix of preference vectors for each node
PrefMat <- t(sapply(as.character(V(graph)),AssignPrefList))
# Attaching PrefList as a node attribute to each node
for (i in 1:x){
V(graph)[as.character(i)]$PrefList <- list(PrefMat[i,])
}
# Women proposing for the first time
V(graph)[V(graph)$gender == "female"]
V(graph)[V(graph)$gender == "female"]$PrefList
sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)
V(graph)$PrefList
# creating edgelist for all female nodes with their first preferences
FirstProposals <- c(rbind(as.character(V(graph)[V(graph)$gender == "female"]), sapply(V(graph)[V(graph)$gender == "female"]$PrefList,"[[",1)))
FirstPropGraph <- add_edges(graph, FirstProposals)
plot(FirstPropGraph, directed = TRUE)
unlist(adjacent_vertices(FirstPropGraph, "2", mode="all"))
as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"])
MaleChoice <- function(x){
# getting all connections for one node
A <- unlist(adjacent_vertices(FirstPropGraph, x, mode="all"))
names(A) <- NULL;A
if(length(A) == 0){
edge <- c(NA,NA)
} else {
# getting ranks in PrefList of that node for the connected ones
match(A,unlist(V(FirstPropGraph)[x]$PrefList))
# picking the proposing women that is the heighest in the PrefList
match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))
A <- as.character(A[match(A,unlist(V(FirstPropGraph)[x]$PrefList)) == min(match(A,unlist(V(FirstPropGraph)[x]$PrefList)))])
# saving edge
edge <- c(x,A)
}
return(edge)
}
B <- lapply(as.character(V(FirstPropGraph)[V(FirstPropGraph)$gender == "male"]),MaleChoice);B
B <- unlist(B)
MaleChoiceEdges <- B[is.na(B) == FALSE]
# deleting old edges
MaleChoiceGraph <- FirstPropGraph
MaleChoiceGraph <- delete.edges(MaleChoiceGraph, E(MaleChoiceGraph))
# adding new edges + plotting
MaleChoiceGraph <-add_edges(MaleChoiceGraph,MaleChoiceEdges)
plot(MaleChoiceGraph)
degree(MaleChoiceGraph,V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"])
degree(MaleChoiceGraph,V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]) == 0
names(degree(MaleChoiceGraph,V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]) == 0)
V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]
V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"][degree(MaleChoiceGraph,V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]) == 0]
# all rejected women go for second choice
C <- as.character(V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"][degree(MaleChoiceGraph,V(MaleChoiceGraph)[V(MaleChoiceGraph)$gender == "female"]) == 0])
C
rm(list=ls())
### acticating library
library(parallel)
### parallel job
cat(paste("There are",detectCores(),"cores available"),sep = " ")
### creating a list of 100 vectors with 10.000 random numbers each
runif(10.000,-5000,5000)
### creating a list of 100 vectors with 10.000 random numbers each
runif(10000,-5000,5000)
### creating a list of 100 vectors with 10.000 random numbers each
Numbers <- vector("list",100)
Test <- function(x){
x <- runif(100000,-5000,5000)
return(summary(x))
}
Test(Numbers[1])
Test(Numbers[1])
### parallel job
cat(paste("There are",detectCores(),"cores available"),sep = " ")
Test(Numbers[1])
Numbers2 <- mclapply(Numbers,Test, mc.cores = detectCores()-1)
View(Numbers2)
### creating a list of 100 vectors with 10.000 random numbers each
Numbers <- vector("list",10000)
Test <- function(x){
x <- runif(100000,-5000,5000)
return(summary(x))
}
### parallel job
cat(paste("There are",detectCores(),"cores available"),sep = " ")
Numbers2 <- mclapply(Numbers,Test, mc.cores = detectCores()-1)
View(Numbers2)
save(Numbers2,"TestOutput.Rdata")
save(Numbers2,file = "TestOutput.Rdata")
getwd()
rm(list=ls())
#### This is a script for testing the parallel function of the CHEOPS Server
#### Testing importing packages
## importing packages
if("igraph" %in% installed.packages() != TRUE) {
install.packages("igraph")
}
if("tidyverse" %in% installed.packages() != TRUE) {
install.packages("tidyverse")
}
if("tictoc" %in% installed.packages() != TRUE) {
install.packages("tictoc")
}
if("parallel" %in% installed.packages() != TRUE) {
install.packages("parallel")
}
if("data.table" %in% installed.packages() != TRUE) {
install.packages("data.table")
}
if("threejs" %in% installed.packages() != TRUE) {
install.packages("threejs")
}
if("htmlwidgets" %in% installed.packages() != TRUE) {
install.packages("htmlwidgets")
}
if("pbmcapply" %in% installed.packages() != TRUE) {
install.packages("pbmcapply")
}
### acticating library
library(parallel)
### creating a list of 100 vectors with 10.000 random numbers each
Numbers <- vector("list",10000)
Test <- function(x){
x <- runif(100000,-5000,5000)
return(summary(x))
}
### parallel job
cat(paste("There are",detectCores(),"cores available"),sep = " ")
Numbers2 <- mclapply(Numbers,Test, mc.cores = detectCores()-1)
save(Numbers2,file = "TestOutput.Rdata")
install.packages("tidyverse",repos="https://cran.uni-muenster.de")
strtoi(Sys.getenv(c("SLURM_NTASKS")))
setwd("~/Desktop/R-Projects/Arbeit/SimulatingNormativeConflict")
# sourcing function
source("Simulation.R")
Simulation(nodes = 2000,
r = 1,
g = 0.3,
h = 0.5,
iter = 100,
cores = 3)
load("/home/juko/Desktop/R-Projects/Arbeit/SimulatingNormativeConflict/Output/NormResultsDF.RData")
View(Output)
plot(Output$MajorityNormPercentageOverall)
plot(Output$MajorityNormPercentageInMajority)
plot(Output$MajorityNormPercentageInMinority)
plot(Output$PercMajMajEdgesBetween)
setwd("~/Desktop/R-Projects/Arbeit/SimulatingNormativeConflict")
# invoking cluster to use multiple nodes
library(parallel)
# sourcing function
source("Simulation.R")
cat(CoreAmount)
# setting the amount of cores
CoreAmount <- detectCores()
cat(CoreAmount)
# sourcing function
source("Simulation.R")
Simulation(nodes = 2000,
r = 1,
g = 0.3,
h = 0.5,
iter = 300,
cores = CoreAmount-1)
load("/home/juko/Desktop/R-Projects/Arbeit/SimulatingNormativeConflict/Output/NormResultsDF.RData")
View(Output)
# importing libraries
library(parallel)
# making a cluster
cl <- makeCluster()
# making a cluster
detectCores()
cl <- makeCluster(3,type= "MPI")
install.packages("snow")
cl <- makeCluster(3,type= "MPI")
install.packages("Rmpi")
lapply(cl,list(rep("Test",100),function(x){print(x)}))
lapply(cl,list(rep("Test",100),function(x){cat(x)}))
list(rep("Test",100))
lapply(cl,list(rep("Test",100)),function(x){cat(x)})
lapply(cl,function(x){cat("Test")})
parLapply(cl,function(x){cat("Test")})
# making cluster
cl <- makeCluster(strtoi(Sys.getenv(c("SLURM_NTASKS")))-1, type="MPI");cl
setwd("~/Desktop/R-Projects/Arbeit/SimulatingNormativeConflict")
# sourcing function
source("Simulation.R")
Simulation(nodes = 200,
r = 1,
g = 0.2,
h = 0.5,
iter = 300,
cores = 3)
load("/home/juko/Desktop/R-Projects/Arbeit/SimulatingNormativeConflict/Output/NormResultsDF.RData")
View(Output)
load("/home/juko/Desktop/R-Projects/Arbeit/SimulatingNormativeConflict/ServerOutput/NormResultsDF.RData")
View(Output)
plot(Output$IterationNumber)
